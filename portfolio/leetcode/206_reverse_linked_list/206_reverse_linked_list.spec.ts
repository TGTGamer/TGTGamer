/**
 * @format
 * -----
 * Project: TGTGamer
 * File: 206_reverse_linked_list.spec.ts
 * Path: \portfolio\LeetCode\206_reverse_linked_list\206_reverse_linked_list.spec.ts
 * Created Date: Tuesday, January 16th 2024
 * Author: Jonathan Stevens (Email: jonathan@resnovas.com, Github: https://github.com/TGTGamer)
 * -----
 * Contributing: Please read through our contributing guidelines. Included are directions for opening
 * issues, coding standards, and notes on development. These can be found at https://github.com/TGTGamer/blob/develop/CONTRIBUTING.md
 * 
 * Code of Conduct: This project abides by the Contributor Covenant, version 2.0. Please interact in ways that contribute to an open,
 * welcoming, diverse, inclusive, and healthy community. Our Code of Conduct can be found at https://github.com/TGTGamer/blob/develop/CODE_OF_CONDUCT.md
 * -----
 * Copyright (c) 2024 Resnovas - All Rights Reserved
 * LICENSE: Creative Commons Zero v1.0 Universal (CC0-1.0)
 * -----
 * This program has been provided under confidence of the copyright holder and is 
 * licensed for copying, distribution and modification under the terms of
 * the Creative Commons Zero v1.0 Universal (CC0-1.0) published as the License,
 * or (at your option) any later version of this license.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * Creative Commons Zero v1.0 Universal for more details.
 * 
 * You should have received a copy of the Creative Commons Zero v1.0 Universal
 * along with this program. If not, please write to: jonathan@resnovas.com,
 * or see https://creativecommons.org/publicdomain/zero/1.0/legalcode
 * 
 * DELETING THIS NOTICE AUTOMATICALLY VOIDS YOUR LICENSE - PLEASE SEE THE LICENSE FILE FOR DETAILS
 */

import { ListNode, ReverseLinkedList } from './206_reverse_linked_list.js';

// Generated by CodiumAI

describe('ReverseLinkedList', () => {

  // Should reverse a linked list with multiple nodes
  it('should reverse a linked list with multiple nodes', () => {
    // Given a linked list with multiple nodes
    const head = new ListNode(1);
    head.next = new ListNode(2);
    head.next.next = new ListNode(3);

    // When ReverseLinkedList is called with the head of the linked list
    const result = ReverseLinkedList(head);

    // Then the linked list should be reversed
    expect(result?.val).toBe(3);
    expect(result?.next?.val).toBe(2);
    expect(result?.next?.next?.val).toBe(1);
    expect(result?.next?.next?.next).toBeNull();
  });

  // Should reverse a linked list with two nodes
  it('should reverse a linked list with two nodes', () => {
    // Given a linked list with two nodes
    const head = new ListNode(1);
    head.next = new ListNode(2);

    // When ReverseLinkedList is called with the head of the linked list
    const result = ReverseLinkedList(head);

    // Then the linked list should be reversed
    expect(result?.val).toBe(2);
    expect(result?.next?.val).toBe(1);
    expect(result?.next?.next).toBeNull();
  });

  // Should return the same node if the linked list has only one node
  it('should return the same node if the linked list has only one node', () => {
    // Given a linked list with only one node
    const head = new ListNode(1);

    // When ReverseLinkedList is called with the head of the linked list
    const result = ReverseLinkedList(head);

    // Then the same node should be returned
    expect(result?.val).toBe(1);
    expect(result?.next).toBeNull();
  });

  // Should return null if the linked list is empty
  it('should return null if the linked list is empty', () => {
    // Given an empty linked list
    const head = null;

    // When ReverseLinkedList is called with the head of the linked list
    const result = ReverseLinkedList(head);

    // Then null should be returned
    expect(result).toBeNull();
  });

  // Should handle a circular linked list by breaking the loop and reversing it
  it.skip('should handle a circular linked list by breaking the loop and reversing it', () => {
    // Given a circular linked list with three nodes
    const head = new ListNode(1);
    head.next = new ListNode(2);
    head.next.next = new ListNode(3);
    head.next.next.next = head;

    // When ReverseLinkedList is called with the head of the linked list
    const result = ReverseLinkedList(head);

    // Then the circular loop should be broken and the linked list should be reversed
    expect(result?.val).toBe(3);
    expect(result?.next?.val).toBe(2);
    expect(result?.next?.next?.val).toBe(1);
    expect(result?.next?.next?.next).toBeNull();
  });

  // Should handle a linked list with duplicate values by reversing it correctly
  it('should handle a linked list with duplicate values by reversing it correctly', () => {
    // Given a linked list with duplicate values
    const head = new ListNode(1);
    head.next = new ListNode(1);
    head.next.next = new ListNode(2);

    // When ReverseLinkedList is called with the head of the linked list
    const result = ReverseLinkedList(head);

    // Then the linked list should be reversed correctly, preserving the duplicate values
    expect(result?.val).toBe(2);
    expect(result?.next?.val).toBe(1);
    expect(result?.next?.next?.val).toBe(1);
    expect(result?.next?.next?.next).toBeNull();
  });

  // Should handle a linked list with a very large number of nodes
  it('should handle a linked list with a very large number of nodes', () => {
    // Given a linked list with a very large number of nodes
    const head = new ListNode(1);
    let current = head;
    for (let i = 2; i <= 1000000; i++) {
      current.next = new ListNode(i);
      current = current.next;
    }

    // When ReverseLinkedList is called with the head of the linked list
    const result = ReverseLinkedList(head);

    // Then the linked list should be reversed correctly
    expect(result?.val).toBe(1000000);
    expect(result?.next?.val).toBe(999999);
    expect(result?.next?.next?.val).toBe(999998);
    // ... continue with more assertions for other nodes
  });

  // Should handle a linked list with a very small number of nodes
  it('should handle a linked list with a very small number of nodes', () => {
    // Given a linked list with a very small number of nodes
    const head = new ListNode(1);

    // When ReverseLinkedList is called with the head of the linked list
    const result = ReverseLinkedList(head);

    // Then the linked list should be reversed correctly
    expect(result?.val).toBe(1);
    expect(result?.next).toBeNull();
  });

  // Should handle a linked list with nodes containing very large numbers
  it('should handle a linked list with nodes containing very large numbers', () => {
    // Given a linked list with nodes containing very large numbers
    const head = new ListNode(1000000000);
    head.next = new ListNode(2000000000);
    head.next.next = new ListNode(3000000000);

    // When ReverseLinkedList is called with the head of the linked list
    const result = ReverseLinkedList(head);

    // Then the linked list should be reversed correctly
    expect(result?.val).toBe(3000000000);
    expect(result?.next?.val).toBe(2000000000);
    expect(result?.next?.next?.val).toBe(1000000000);
    expect(result?.next?.next?.next).toBeNull();
  });

  // Should handle a linked list with nodes containing very small numbers
  it('should handle a linked list with nodes containing very small numbers', () => {
    // Given a linked list with nodes containing very small numbers
    const head = new ListNode(-1000000000);
    head.next = new ListNode(-2000000000);
    head.next.next = new ListNode(-3000000000);

    // When ReverseLinkedList is called with the head of the linked list
    const result = ReverseLinkedList(head);

    // Then the linked list should be reversed correctly
    expect(result?.val).toBe(-3000000000);
    expect(result?.next?.val).toBe(-2000000000);
    expect(result?.next?.next?.val).toBe(-1000000000);
    expect(result?.next?.next?.next).toBeNull();
  });

  // Should handle a linked list with nodes containing undefined values
  it('should handle a linked list with nodes containing undefined values', () => {
    // Given a linked list with nodes containing undefined values
    const head = new ListNode(undefined);
    head.next = new ListNode(undefined);
    head.next.next = new ListNode(undefined);

    // When ReverseLinkedList is called with the head of the linked list
    const result = ReverseLinkedList(head);

    // Then the linked list should be reversed correctly
    expect(result?.val).toBeUndefined();
    expect(result?.next?.val).toBeUndefined();
    expect(result?.next?.next?.val).toBeUndefined();
    expect(result?.next?.next?.next).toBeNull();
  });

  // Should handle a linked list with negative values by reversing it correctly
  it('should reverse a linked list with negative values', () => {
    // Given a linked list with negative values
    const head = new ListNode(-1);
    head.next = new ListNode(-2);
    head.next.next = new ListNode(-3);

    // When ReverseLinkedList is called with the head of the linked list
    const result = ReverseLinkedList(head);

    // Then the linked list should be reversed
    expect(result?.val).toBe(-3);
    expect(result?.next?.val).toBe(-2);
    expect(result?.next?.next?.val).toBe(-1);
    expect(result?.next?.next?.next).toBeNull();
  });

  // Should handle a linked list with decimal values by reversing it correctly
  it('should reverse a linked list with decimal values', () => {
    // Given a linked list with decimal values
    const head = new ListNode(1.5);
    head.next = new ListNode(2.5);
    head.next.next = new ListNode(3.5);

    // When ReverseLinkedList is called with the head of the linked list
    const result = ReverseLinkedList(head);

    // Then the linked list should be reversed
    expect(result?.val).toBe(3.5);
    expect(result?.next?.val).toBe(2.5);
    expect(result?.next?.next?.val).toBe(1.5);
    expect(result?.next?.next?.next).toBeNull();
  });

  // Should handle a linked list with a mix of positive, negative, and decimal values by reversing it correctly
  it('should reverse a linked list with a mix of positive, negative, and decimal values', () => {
    // Given a linked list with a mix of positive, negative, and decimal values
    const head = new ListNode(1);
    head.next = new ListNode(-2);
    head.next.next = new ListNode(3.5);

    // When ReverseLinkedList is called with the head of the linked list
    const result = ReverseLinkedList(head);

    // Then the linked list should be reversed
    expect(result?.val).toBe(3.5);
    expect(result?.next?.val).toBe(-2);
    expect(result?.next?.next?.val).toBe(1);
    expect(result?.next?.next?.next).toBeNull();
  });

});