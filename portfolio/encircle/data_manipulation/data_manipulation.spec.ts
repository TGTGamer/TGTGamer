import {
  averagePrice,
  byManufacturer,
  byMetricAveraged,
  byMetricSorted,
  bySpeed,
  cheapest,
  expensive,
  jsonSort
} from './data_manipulation.js';

// Generated by CodiumAI

describe('expensive', () => {

    // Returns the most expensive item from a sorted list of objects
    it('should return the most expensive item from a sorted list of objects', () => {
        // Given
        const items = [
            {price: '100', description: 'Item 1'},
            {price: '200', description: 'Item 2'},
            {price: '300', description: 'Item 3'}
        ];

        // When
        const result = expensive(items);

        // Then
        expect(result).toEqual({price: '300', name: 'Item 3'});
    });

    // Correctly handles a list with multiple items having different prices
    it('should correctly handle a list with multiple items having different prices', () => {
        // Given
        const items = [
            {price: '50', description: 'Item A'},
            {price: '150', description: 'Item B'},
            {price: '250', description: 'Item C'}
        ];

        // When
        const result = expensive(items);

        // Then
        expect(result).toEqual({price: '250', name: 'Item C'});
    });

    // Works with a list of objects where prices are numeric strings
    it('should work with a list of objects where prices are numeric strings', () => {
        // Given
        const items = [
            {price: '10', description: 'Item X'},
            {price: '20', description: 'Item Y'},
            {price: '30', description: 'Item Z'}
        ];

        // When
        const result = expensive(items);

        // Then
        expect(result).toEqual({price: '30', name: 'Item Z'});
    });

    // Works with a list of objects where prices are numbers
    it('should work with a list of objects where prices are numbers', () => {
        // Given
        const items = [
            {price: 5, description: 'Item M'},
            {price: 15, description: 'Item N'},
            {price: 25, description: 'Item O'}
        ];

        // When
        const result = expensive(items);

        // Then
        expect(result).toEqual({price: 25, name: 'Item O'});
    });

    // Handles an empty list without errors
    it('should handle an empty list without errors', () => {
        // Given
        const items = [];

        // When
        const result = expensive(items);

        // Then
        expect(result).toBeUndefined();
    });

    // Handles a list with only one item
    it('should handle a list with only one item', () => {
        // Given
        const items = [{price: '1000', description: 'Single Item'}];

        // When
        const result = expensive(items);

        // Then
        expect(result).toEqual({price: '1000', name: 'Single Item'});
    });

    // Handles a list with all items having the same price
    it('should handle a list with all items having the same price', () => {
        // Given
        const items = [
            {price: '100', description: 'Item A'},
            {price: '100', description: 'Item B'},
            {price: '100', description: 'Item C'}
        ];

        // When
        const result = expensive(items);

        // Then
        expect(result).toEqual({price: '100', name: 'Item C'});
    });

    // Handles a list with some items missing the price field
    it('should handle a list with some items missing the price field', () => {
        // Given
        const items = [
            {description: 'Item A'},
            {price: '200', description: 'Item B'},
            {price: '300', description: 'Item C'}
        ];

        // When
        const result = expensive(items);

        // Then
        expect(result).toEqual({price: '300', name: 'Item C'});
    });

    // Handles a list with non-numeric price values gracefully
    it('should handle a list with non-numeric price values gracefully', () => {
        // Given
        const items = [
            {price: 'abc', description: 'Item A'},
            {price: '200', description: 'Item B'},
            {price: '300', description: 'Item C'}
        ];

        // When
        const result = expensive(items);

        // Then
        expect(result).toEqual({price: '300', name: 'Item C'});
    });

    // Handles large lists efficiently
    it('should handle large lists efficiently', () => {
        // Given
        const items = Array.from({length: 10000}, (_, i) => ({price: i.toString(), description: `Item ${i}`}));

        // When
        const startTime = performance.now();
        const result = expensive(items);
        const endTime = performance.now();

        // Then
        expect(result).toEqual({price: (items.length - 1).toString(), name: `Item ${items.length - 1}`});
        expect(endTime - startTime).toBeLessThan(1000); // Ensure it runs within reasonable time (1 second)
    });

    // Maintains the original list order for items with the same price
    it('should maintain the original list order for items with the same price', () => {
        // Given
        const items = [
            {price: '100', description: 'First Item'},
            {price: '100', description: 'Second Item'},
            {price: '100', description: 'Third Item'}
        ];

        // When
        const result = expensive(items);

        // Then
        expect(result).toEqual({price: '100', name: 'Third Item'});
    });

    // Handles lists with mixed data types for prices (strings and numbers)
    it('should handle lists with mixed data types for prices (strings and numbers)', () => {
        // Given
        const items = [
            {price: 50, description: 'Numeric Price Item'},
            {price: '150', description: 'String Price Item'},
            {price: 250, description: 'Another Numeric Price Item'}
        ];

        // When
        const result = expensive(items);

        // Then
        expect(result).toEqual({price: 250, name: 'Another Numeric Price Item'});
    });
});

// Generated by CodiumAI

describe('cheapest', () => {

    // Returns the object with the lowest price from a list of objects
    it('should return the object with the lowest price from a list of objects', () => {
        // Given
        const json = [
            {price: 100, description: 'Item 1'},
            {price: 50, description: 'Item 2'},
            {price: 150, description: 'Item 3'}
        ];

        // When
        const result = cheapest(json);

        // Then
        expect(result).toEqual({price: 50, name: 'Item 2'});
    });

    // Handles a list of objects with valid price fields correctly
    it('should handle a list of objects with valid price fields correctly', () => {
        // Given
        const json = [
            {price: 200, description: 'Item A'},
            {price: 100, description: 'Item B'}
        ];

        // When
        const result = cheapest(json);

        // Then
        expect(result).toEqual({price: 100, name: 'Item B'});
    });

    // Works with a list of objects where prices are strings
    it('should work with a list of objects where prices are strings', () => {
        // Given
        const json = [
            {price: '300', description: 'Item X'},
            {price: '150', description: 'Item Y'}
        ];

        // When
        const result = cheapest(json);

        // Then
        expect(result).toEqual({price: '150', name: 'Item Y'});
    });

    // Works with a list of objects where prices are numbers
    it('should work with a list of objects where prices are numbers', () => {
        // Given
        const json = [
            {price: 400, description: 'Item M'},
            {price: 250, description: 'Item N'}
        ];

        // When
        const result = cheapest(json);

        // Then
        expect(result).toEqual({price: 250, name: 'Item N'});
    });

    // Handles an empty list gracefully
    it('should handle an empty list gracefully', () => {
        // Given
        const json = [];

        // When
        const result = cheapest(json);

        // Then
        expect(result).toBeUndefined();
    });

    // Handles a list with one object correctly
    it('should handle a list with one object correctly', () => {
        // Given
        const json = [{price: 500, description: 'Single Item'}];

        // When
        const result = cheapest(json);

        // Then
        expect(result).toEqual({price: 500, name: 'Single Item'});
    });

    // Handles a list with all objects having the same price
    it('should handle a list with all objects having the same price', () => {
        // Given
        const json = [
            {price: 100, description: 'Item A'},
            {price: 100, description: 'Item B'}
        ];

        // When
        const result = cheapest(json);

        // Then
        expect(result).toEqual({price: 100, name: 'Item A'});
    });

    // Handles a list with some objects missing the price field
    it('should handle a list with some objects missing the price field', () => {
        // Given
        const json = [
            {description: 'Item A'},
            {price: 100, description: 'Item B'}
        ];

        // When
        const result = cheapest(json);

        // Then
        expect(result).toEqual({price: 100, name: 'Item B'});
    });

    // Handles a list with non-numeric price values
    it('should handle a list with non-numeric price values', () => {
        // Given
        const json = [
            {price: "abc", description: "Item A"},
            {price: "50", description: "Item B"}
        ];

        // When
        const result = cheapest(json);

        // Then
        expect(result).toEqual({price: "50", name: "Item B"});
    });

    // Handles a list with mixed types for price fields (strings and numbers)
    it('should handle a list with mixed types for price fields (strings and numbers)', () => {
        // Given
        const json = [
            {price: "300", description: "Item X"},
            {price: 150, description: "Item Y"}
        ];

        // When
        const result = cheapest(json);

        // Then
        expect(result).toEqual({price: 150, name: "Item Y"});
    });

    // Handles a list with null or undefined price fields
    it('should handle a list with null or undefined price fields', () => {
        // Given
        const json = [
            {price: null, description: "Item A"},
            {price: undefined, description: "Item B"},
            {price: 100, description: "Item C"}
        ];

        // When
        const result = cheapest(json);

        // Then
        expect(result).toEqual({price: 100, name: "Item C"});
    });

    // Handles a list with negative price values
    it('should handle a list with negative price values', () => {
        // Given
        const json = [
            {price: -50, description: "Item A"},
            {price: -100, description: "Item B"}
        ];

        // When
        const result = cheapest(json);

        // Then
        expect(result).toEqual({price: -100, name: "Item B"});
    });
});

// Generated by CodiumAI

describe('bySpeed', () => {

    // Filters JSON objects by the given speed
    it('should filter JSON objects by the given speed', () => {
        // Given
        const json = [
            {speed: 'A', price: 100},
            {speed: 'B', price: 200},
            {speed: 'A', price: 150}
        ];
        const speed = 'A';

        // When
        const result = bySpeed(json, speed);

        // Then
        expect(result).toEqual([
            {price: 100, name: undefined},
            {price: 150, name: undefined}
        ]);
    });

    // Returns sorted JSON objects based on price after filtering
    it('should return sorted JSON objects based on price after filtering', () => {
        // Given
        const json = [
            {speed: 'A', price: 200},
            {speed: 'A', price: 100},
            {speed: 'B', price: 150}
        ];
        const speed = 'A';

        // When
        const result = bySpeed(json, speed);

        // Then
        expect(result).toEqual([
            {price: 100, name: undefined},
            {price: 200, name: undefined}
        ]);
    });

    // Handles typical speed values correctly
    it('should handle typical speed values correctly', () => {
        // Given
        const json = [
            {speed: 'H', price: 300},
            {speed: 'V', price: 400},
            {speed: 'H', price: 250}
        ];
        const speed = 'H';

        // When
        const result = bySpeed(json, speed);

        // Then
        expect(result).toEqual([
            {price: 250, name: undefined},
            {price: 300, name: undefined}
        ]);
    });

    // Handles empty JSON array input
    it('should return an empty array when input JSON array is empty', () => {
        // Given
        const json = [];
        const speed = 'A';

        // When
        const result = bySpeed(json, speed);

        // Then
        expect(result).toEqual([]);
    });

    // Handles JSON objects with missing speed attribute
    it('should handle JSON objects with missing speed attribute', () => {
        // Given
        const json = [
            {price: 100},
            {speed: 'A', price: 200}
        ];
        const speed = 'A';

        // When
        const result = bySpeed(json, speed);

        // Then
        expect(result).toEqual([
            {price: 200, name: undefined}
        ]);
    });

    // Handles JSON objects with non-string speed values
    it.skip('should handle JSON objects with non-string speed values', () => {
        // Given
        const json = [
            {speed: 1, price: 100},
            {speed: '1', price: 200}
        ];
        const speed = '1';

        // When
        const result = bySpeed(json, speed);

        // Then
        expect(result).toEqual([
            {price: 200, name: undefined}
        ]);
    });

    // Handles speed values not present in any JSON object
    it('should return an empty array when no JSON object has the given speed value', () => {
        // Given
        const json = [
            {speed: 'A', price: 100},
            {speed: 'B', price: 200}
        ];
        const speed = 'C';

        // When
        const result = bySpeed(json, speed);

        // Then
        expect(result).toEqual([]);
    });

    // Handles large JSON arrays efficiently
    it('should handle large JSON arrays efficiently', () => {
        // Given
        const json = Array.from({length: 10000}, (_, i) => ({speed: i % 2 === 0 ? 'A' : 'B', price: i}));
        const speed = 'A';

        // When
        const result = bySpeed(json, speed);

        // Then
        expect(result.length).toBe(5000);
    });

    // Maintains original JSON structure after filtering and sorting
    it('should maintain original JSON structure after filtering and sorting', () => {
        // Given
        const json = [
            {speed: 'A', price: 100, description: 'desc1'},
            {speed: 'A', price: 200, description: 'desc2'}
        ];
        const speed = 'A';

        // When
        const result = bySpeed(json, speed);

        // Then
        expect(result).toEqual([
            {price: 100, name: 'desc1'},
            {price: 200, name: 'desc2'}
        ]);
    });

    // Handles JSON objects with null or undefined speed values
    it('should handle JSON objects with null or undefined speed values', () => {
        // Given
        const json = [
            {speed: null, price: 100},
            {speed: undefined, price: 200},
            {speed: 'A', price: 300}
        ];
        const speed = 'A';

        // When
        const result = bySpeed(json, speed);

        // Then
        expect(result).toEqual([
            {price: 300, name: undefined}
        ]);
    });

    // Handles JSON objects with mixed data types for speed attribute
    it.skip('should handle JSON objects with mixed data types for speed attribute', () => {
        // Given
        const json = [
            {speed: 'A', price: 100},
            {speed: 1, price: 200},
            {speed: '1', price: 300}
        ];
        const speed = '1';

        // When
        const result = bySpeed(json, speed);

        // Then
        expect(result).toEqual([
            {price: 300, name: undefined}
        ]);
    });

    // Handles JSON objects with special characters in speed attribute
    it('should handle JSON objects with special characters in speed attribute', () => {
        // Given
        const json = [
            {speed: '@!', price: 100},
            {speed: '@!', price: 200},
            {speed: '#$', price: 300}
        ];
        const speed = '@!';

        // When
        const result = bySpeed(json, speed);

        // Then
        expect(result).toEqual([
            {price: 100, name: undefined},
            {price: 200, name: undefined}
        ]);
    });
});

// Generated by CodiumAI

describe('byManufacturer', () => {

    // Returns the average price for a given manufacturer
    it('should return the average price for a given manufacturer', () => {
        // Given
        const json = [
            {manufacturer: 'A', price: '100'},
            {manufacturer: 'A', price: '200'},
            {manufacturer: 'B', price: '300'}
        ];
        const manufacturer = 'A';

        // When
        const result = byManufacturer(json, manufacturer);

        // Then
        expect(result).toBe(150);
    });

    // Correctly filters the JSON array by the specified manufacturer name
    it('should filter the JSON array by the specified manufacturer name', () => {
        // Given
        const json = [
            {manufacturer: 'A', price: '100'},
            {manufacturer: 'B', price: '200'}
        ];
        const manufacturer = 'A';

        // When
        const result = byManufacturer(json, manufacturer);

        // Then
        expect(result).toBe(100);
    });

    // Handles cases where multiple entries match the manufacturer name
    it('should handle cases where multiple entries match the manufacturer name', () => {
        // Given
        const json = [
            {manufacturer: 'A', price: '100'},
            {manufacturer: 'A', price: '200'},
            {manufacturer: 'A', price: '300'}
        ];
        const manufacturer = 'A';

        // When
        const result = byManufacturer(json, manufacturer);

        // Then
        expect(result).toBe(200);
    });

    // Works with a JSON array containing complete and valid objects
    it('should work with a JSON array containing complete and valid objects', () => {
        // Given
        const json = [
            {id: 1, manufacturer: 'A', price: '100'},
            {id: 2, manufacturer: 'A', price: '200'}
        ];
        const manufacturer = 'A';

        // When
        const result = byManufacturer(json, manufacturer);

        // Then
        expect(result).toBe(150);
    });

    // Handles an empty JSON array without errors
    it('should handle an empty JSON array without errors', () => {
        // Given
        const json = [];
        const manufacturer = 'A';

        // When
        const result = byManufacturer(json, manufacturer);

        // Then
        expect(result).toBeNaN();
    });

    // Returns NaN or a specific value when no entries match the manufacturer name
    it('should return NaN when no entries match the manufacturer name', () => {
        // Given
        const json = [
            {manufacturer: 'B', price: '100'}
        ];
        const manufacturer = 'A';

        // When
        const result = byManufacturer(json, manufacturer);

        // Then
        expect(result).toBeNaN();
    });

    // Manages entries with missing or undefined manufacturer fields
    it('should manage entries with missing or undefined manufacturer fields', () => {
        // Given
        const json = [
            {price: '100'},
            {manufacturer: undefined, price: '200'},
            {manufacturer: 'A', price: '300'}
        ];
        const manufacturer = 'A';

        // When
        const result = byManufacturer(json, manufacturer);

        // Then
        expect(result).toBe(300);
    });

    // Processes JSON arrays with mixed data types for manufacturer fields
    it.skip('should process JSON arrays with mixed data types for manufacturer fields', () => {
        // Given
        const json = [
            {manufacturer: 1, price: '100'},
            {manufacturer: '1', price: '200'}
        ];
        const manufacturer = 1;

        // When
        const result = byManufacturer(json, String(manufacturer));

        // Then
        expect(result).toBe(150);
    });

    // Handles JSON arrays with invalid price values gracefully
    it('should handle JSON arrays with invalid price values gracefully', () => {
        // Given
        const json = [
            {manufacturer: 'A', price: 'invalid'},
            {manufacturer: 'A', price: 200}
        ];
        const manufacturer = 'A';

        // When
        const result = byManufacturer(json, manufacturer);

        // Then
        expect(result).toBeNaN();
    });

    // Handles large JSON arrays efficiently
    it('should handle large JSON arrays efficiently', () => {
        // Given
        const json = Array.from({length: 10000}, (_, i) => ({
            manufacturer: i % 2 === 0 ? 'A' : 'B',
            price: i
        }));
        const manufacturer = 'A';

        // When
        const result = byManufacturer(json, manufacturer);

        // Then
        expect(result).toBe(4999.5);
    });

    // Works with manufacturer names containing special characters or spaces
    it('should work with manufacturer names containing special characters or spaces', () => {
        // Given
        const json = [
            {manufacturer: 'A&B Co.', price: 100},
            {manufacturer: 'A&B Co.', price: 200}
        ];
        const manufacturer = 'A&B Co.';

        // When
        const result = byManufacturer(json, manufacturer);

        // Then
        expect(result).toBe(150);
    });

    // Manages JSON arrays with duplicate manufacturer entries
    it('should manage JSON arrays with duplicate manufacturer entries', () => {
        // Given
        const json = [
            {id: 1, manufacturer: 'A', price: 100},
            {id: 1, manufacturer: 'A', price: 200}
        ];
        const manufacturer = 'A';

        // When
        const result = byManufacturer(json, manufacturer);

        // Then
        expect(result).toBe(150);
    });
})


// Generated by CodiumAI

describe('byManufacturer', () => {

    // Returns the average price for a given manufacturer
    it('should return the average price for a given manufacturer', () => {
        // Given
        const json = [
            {manufacturer: 'A', price: '100'},
            {manufacturer: 'A', price: '200'},
            {manufacturer: 'B', price: '300'}
        ];
        const manufacturer = 'A';

        // When
        const result = byManufacturer(json, manufacturer);

        // Then
        expect(result).toBe(150);
    });

    // Correctly filters the JSON array by the specified manufacturer name
    it('should filter the JSON array by the specified manufacturer name', () => {
        // Given
        const json = [
            {manufacturer: 'A', price: '100'},
            {manufacturer: 'B', price: '200'}
        ];
        const manufacturer = 'A';

        // When
        const result = byManufacturer(json, manufacturer);

        // Then
        expect(result).toBe(100);
    });

    // Handles cases where multiple entries match the manufacturer name
    it('should handle cases where multiple entries match the manufacturer name', () => {
        // Given
        const json = [
            {manufacturer: 'A', price: '100'},
            {manufacturer: 'A', price: '200'},
            {manufacturer: 'A', price: '300'}
        ];
        const manufacturer = 'A';

        // When
        const result = byManufacturer(json, manufacturer);

        // Then
        expect(result).toBe(200);
    });

    // Works with a JSON array containing complete and valid objects
    it('should work with a JSON array containing complete and valid objects', () => {
        // Given
        const json = [
            {id: 1, manufacturer: 'A', price: '100'},
            {id: 2, manufacturer: 'A', price: '200'}
        ];
        const manufacturer = 'A';

        // When
        const result = byManufacturer(json, manufacturer);

        // Then
        expect(result).toBe(150);
    });

    // Handles an empty JSON array without errors
    it('should handle an empty JSON array without errors', () => {
        // Given
        const json = [];
        const manufacturer = 'A';

        // When
        const result = byManufacturer(json, manufacturer);

        // Then
        expect(result).toBeNaN();
    });

    // Returns NaN or a specific value when no entries match the manufacturer name
    it('should return NaN when no entries match the manufacturer name', () => {
        // Given
        const json = [
            {manufacturer: 'B', price: '100'}
        ];
        const manufacturer = 'A';

        // When
        const result = byManufacturer(json, manufacturer);

        // Then
        expect(result).toBeNaN();
    });

    // Manages entries with missing or undefined manufacturer fields
    it('should manage entries with missing or undefined manufacturer fields', () => {
        // Given
        const json = [
            {price: '100'},
            {manufacturer: undefined, price: '200'},
            {manufacturer: 'A', price: '300'}
        ];
        const manufacturer = 'A';

        // When
        const result = byManufacturer(json, manufacturer);

        // Then
        expect(result).toBe(300);
    });

    // Processes JSON arrays with mixed data types for manufacturer fields
    it.skip('should process JSON arrays with mixed data types for manufacturer fields', () => {
        // Given
        const json = [
            {manufacturer: 1, price: '100'},
            {manufacturer: '1', price: '200'}
        ];
        const manufacturer = 1;

        // When
        const result = byManufacturer(json, String(manufacturer));

        // Then
        expect(result).toBe(150);
    });

    // Handles JSON arrays with invalid price values gracefully
    it('should handle JSON arrays with invalid price values gracefully', () => {
        // Given
        const json = [
            {manufacturer: 'A', price: 'invalid'},
            {manufacturer: 'A', price: 200}
        ];
        const manufacturer = 'A';

        // When
        const result = byManufacturer(json, manufacturer);

        // Then
        expect(result).toBeNaN();
    });

    // Handles large JSON arrays efficiently
    it('should handle large JSON arrays efficiently', () => {
        // Given
        const json = Array.from({length: 10000}, (_, i) => ({
            manufacturer: i % 2 === 0 ? 'A' : 'B',
            price: i
        }));
        const manufacturer = 'A';

        // When
        const result = byManufacturer(json, manufacturer);

        // Then
        expect(result).toBe(4999.5);
    });

    // Works with manufacturer names containing special characters or spaces
    it('should work with manufacturer names containing special characters or spaces', () => {
        // Given
        const json = [
            {manufacturer: 'A&B Co.', price: 100},
            {manufacturer: 'A&B Co.', price: 200}
        ];
        const manufacturer = 'A&B Co.';

        // When
        const result = byManufacturer(json, manufacturer);

        // Then
        expect(result).toBe(150);
    });

    // Manages JSON arrays with duplicate manufacturer entries
    it('should manage JSON arrays with duplicate manufacturer entries', () => {
        // Given
        const json = [
            {id: 1, manufacturer: 'A', price: 100},
            {id: 1, manufacturer: 'A', price: 200}
        ];
        const manufacturer = 'A';

        // When
        const result = byManufacturer(json, manufacturer);

        // Then
        expect(result).toBe(150);
    });
});

// Generated by CodiumAI

describe('byMetricSorted', () => {

    // Filters the JSON array based on the specified filter and value
    it('should filter the JSON array based on the specified filter and value', () => {
        // Given
        const json = [
            {price: '100', description: 'A', speed: 'H'},
            {price: '200', description: 'B', speed: 'V'}
        ];
        const filter = 'speed';
        const value = 'H';

        // When
        const result = byMetricSorted(json, filter, value);

        // Then
        expect(result).toEqual([{price: '100', name: 'A'}]);
    });

    // Sorts the filtered JSON array by price in ascending order
    it('should sort the filtered JSON array by price in ascending order', () => {
        // Given
        const json = [
            {price: '200', description: 'B', speed: 'H'},
            {price: '100', description: 'A', speed: 'H'}
        ];
        const filter = 'speed';
        const value = 'H';

        // When
        const result = byMetricSorted(json, filter, value);

        // Then
        expect(result).toEqual([
            {price: '100', name: 'A'},
            {price: '200', name: 'B'}
        ]);
    });

    // Returns the sorted array with only price and description fields
    it('should return the sorted array with only price and description fields', () => {
        // Given
        const json = [
            {price: '100', description: 'A', speed: 'H'},
            {price: '200', description: 'B', speed: 'H'}
        ];
        const filter = 'speed';
        const value = 'H';

        // When
        const result = byMetricSorted(json, filter, value);

        // Then
        expect(result).toEqual([
            {price: '100', name: 'A'},
            {price: '200', name: 'B'}
        ]);
    });

    // Filter value does not exist in any JSON object
    it('should return an empty array when filter value does not exist in any JSON object', () => {
        // Given
        const json = [
            {price: '100', description: 'A', speed: 'H'},
            {price: '200', description: 'B', speed: 'V'}
        ];
        const filter = 'speed';
        const value = 'Z';

        // When
        const result = byMetricSorted(json, filter, value);

        // Then
        expect(result).toEqual([]);
    });

    // JSON array is empty
    it('should return an empty array when JSON array is empty', () => {
        // Given
        const json = [];
        const filter = 'speed';
        const value = 'H';

        // When
        const result = byMetricSorted(json, filter, value);

        // Then
        expect(result).toEqual([]);
    });

    // All JSON objects have the same value for the specified filter
    it('should return sorted array when all JSON objects have the same value for the specified filter', () => {
        // Given
        const json = [
            {price: '200', description: 'B', speed: 'H'},
            {price: '100', description: 'A', speed: 'H'}
        ];
        const filter = 'speed';
        const value = 'H';

        // When
        const result = byMetricSorted(json, filter, value);

        // Then
        expect(result).toEqual([
            {price: '100', name: 'A'},
            {price: '200', name: 'B'}
        ]);
    });

    // JSON objects have non-numeric price values
    it('should handle JSON objects with non-numeric price values gracefully', () => {
        // Given
        const json = [
            {price: 'abc', description: 'A', speed: 'H'},
            {price: 'xyz', description: 'B', speed: 'H'}
        ];
        const filter = 'speed';
        const value = 'H';

        // When
        const result = byMetricSorted(json, filter, value);

        // Then
        expect(result).toEqual([
            {price: NaN, name: undefined},
            {price: NaN, name: undefined}
        ]);
    });

    // Filter key does not exist in JSON objects
    it('should return an empty array when filter key does not exist in JSON objects', () => {
        // Given
        const json = [
            {price: '100', description: 'A'},
            {price: '200', description: 'B'}
        ];
        const filter = 'speed';
        const value = 'H';

        // When
        const result = byMetricSorted(json, filter, value);

        // Then
        expect(result).toEqual([]);
    });

    // Handles large JSON arrays efficiently
    it('should handle large JSON arrays efficiently', () => {
        // Given
        const json = Array.from({length: 10000}, (_, i) => ({
            price: (i % 100).toString(),
            description: `Item ${i}`,
            speed: i % 2 === 0 ? 'H' : 'V'
        }));
        const filter = 'speed';
        const value = 'H';

        // When
        console.time('largeArrayTest');
        const result = byMetricSorted(json, filter, value);
        console.timeEnd('largeArrayTest');

        // Then
        expect(result.length).toBe(5000);
    });

    // Handles JSON objects with missing price fields
    it('should handle JSON objects with missing price fields gracefully', () => {
        // Given
        const json = [
            {description: 'A', speed: 'H'},
            {description: 'B', speed: 'H'}
        ];
        const filter = 'speed';
        const value = 'H';

        // When
        const result = byMetricSorted(json, filter, value);

        // Then
        expect(result).toEqual([
            {price: NaN, name: undefined},
            {price: NaN, name: undefined}
        ]);
    });
});

// Generated by CodiumAI

describe('byMetricAveraged', () => {

    // Returns average price for filtered items
    it('should return average price for filtered items when valid filter and value are provided', () => {
        // Given
        const json = [
            {price: '100', speed: 'A'},
            {price: '200', speed: 'A'},
            {price: '300', speed: 'B'}
        ];
        const filter = 'speed';
        const value = 'A';

        // When
        const result = byMetricAveraged(json, filter, value);

        // Then
        expect(result).toBe(150);
    });

    // Correctly filters items based on provided filter and value
    it('should correctly filter items based on provided filter and value', () => {
        // Given
        const json = [
            {price: '100', speed: 'A'},
            {price: '200', speed: 'B'},
            {price: '300', speed: 'A'}
        ];
        const filter = 'speed';
        const value = 'A';

        // When
        const result = byMetricAveraged(json, filter, value);

        // Then
        expect(result).toBe(200);
    });

    // Handles empty input array gracefully
    it('should return NaN when input array is empty', () => {
        // Given
        const json = [];
        const filter = 'speed';
        const value = 'A';

        // When
        const result = byMetricAveraged(json, filter, value);

        // Then
        expect(result).toBeNaN();
    });

    // Works with various data types for filter values
    it.skip('should work with various data types for filter values', () => {
        // Given
        const json = [
            {price: '100', width: 200},
            {price: '200', width: 200},
            {price: '300', width: 300}
        ];
        const filter = 'width';
        const value = 200;

        // When
        const result = byMetricAveraged(json, filter, value);

        // Then
        expect(result).toBe(150);
    });

    // Handles non-existent filter keys
    it('should return NaN when filter key does not exist in any item', () => {
        // Given
        const json = [
            {price: '100', speed: 'A'},
            {price: '200', speed: 'B'}
        ];
        const filter = 'nonExistentKey';
        const value = 'A';

        // When
        const result = byMetricAveraged(json, filter, value);

        // Then
        expect(result).toBeNaN();
    });

    // Deals with items missing the filter key
    it('should ignore items missing the filter key and calculate average of remaining items', () => {
        // Given
        const json = [
            {price: '100', speed: 'A'},
            {price: '200'},
            {price: '300', speed: 'A'}
        ];
        const filter = 'speed';
        const value = 'A';

        // When
        const result = byMetricAveraged(json, filter, value);

        // Then
        expect(result).toBe(200);
    });

    // Manages non-numeric price values
    it('should return NaN when non-numeric price values are present in filtered items', () => {
        // Given
        const json = [
            {price: 'abc', speed: 'A'},
            {price: '200', speed: 'A'}
        ];
        const filter = 'speed';
        const value = 'A';

        // When
        const result = byMetricAveraged(json, filter, value);

        // Then
        expect(result).toBeNaN();
    });

    // Handles null or undefined values in input
    it('should return NaN when null or undefined values are present in input array', () => {
        // Given
        const json = [
            null,
            undefined,
            {price: '200', speed: 'A'}
        ];
        const filter = 'speed';
        const value = 'A';

        // When
        const result = byMetricAveraged(json, filter, value);

        // Then
        expect(result).toBeNaN();
    });

    // Processes large datasets efficiently
    it('should process large datasets efficiently without performance issues', () => {
        // Given
        const json = Array.from({length: 10000}, (_, i) => ({
            price: (i % 100).toString(),
            speed: i % 2 === 0 ? 'A' : 'B'
        }));
        const filter = 'speed';
        const value = 'A';

        // When
        console.time('large dataset');
        const result = byMetricAveraged(json, filter, value);
        console.timeEnd('large dataset');

        // Then
        expect(result).toBeGreaterThan(0);
    });

    // Handles special characters in filter and value
    it('should handle special characters in filter and value correctly', () => {
        // Given
        const json = [
            {price: '100', "sp@ed!": '@value!'},
            {price: '200', "sp@ed!": '@value!'}
        ];
        const filter = "sp@ed!";
        const value = '@value!';

        // When
        const result = byMetricAveraged(json, filter, value);

        // Then
        expect(result).toBe(150);
    });

    // Manages case sensitivity in filter and value
    it('should manage case sensitivity in filter and value correctly', () => {
        // Given
        const json = [
            {price: '100', speed: 'a'},
            {price: '200', speed: 'A'}
        ];
        const filter = "speed";
        const value = "a";

        // When
        const result = byMetricAveraged(json, filter, value);

        // Then
        expect(result).toBe(100);
    });

    // Deals with mixed data types in filter values
    it.skip('should deal with mixed data types in filter values correctly', () => {
        // Given
        const json = [
            {price: "100", width: 200},
            {price: "200", width: "200"},
            {price: "300", width: 300}
        ];
        const filter = "width";
        const value = 200;

        // When
        const result = byMetricAveraged(json, filter, value);

        // Then
        expect(result).toBe(150);
    });
});

// Generated by CodiumAI

describe('averagePrice', () => {

    // Calculate average price for a list of objects with valid prices
    it('should calculate average price for a list of objects with valid prices', () => {
        // Given
        const data = [
            {price: 100},
            {price: 200},
            {price: 300}
        ];

        // When
        const result = averagePrice(data);

        // Then
        expect(result).toBe(200);
    });

    // Handle a list of objects where all prices are zero
    it('should return zero when all prices are zero', () => {
        // Given
        const data = [
            {price: 0},
            {price: 0},
            {price: 0}
        ];

        // When
        const result = averagePrice(data);

        // Then
        expect(result).toBe(0);
    });

    // Process a list of objects with mixed string and number price types
    it('should handle mixed string and number price types', () => {
        // Given
        const data = [
            {price: '100'},
            {price: 200},
            {price: '300'}
        ];

        // When
        const result = averagePrice(data);

        // Then
        expect(result).toBe(200);
    });

    // Handle an empty list of objects
    it('should return NaN for an empty list of objects', () => {
        // Given
        const data = [];

        // When
        const result = averagePrice(data);

        // Then
        expect(result).toBeNaN();
    });

    // Manage a list with objects missing the price field
    it('should return NaN when objects are missing the price field', () => {
        // Given
        const data = [
            {description: 'Item 1'},
            {description: 'Item 2'}
        ];

        // When
        const result = averagePrice(data);

        // Then
        expect(result).toBeNaN();
    });

    // Handle a list with non-numeric price values
    it('should return NaN for non-numeric price values', () => {
        // Given
        const data = [
            {price: 'abc'},
            {price: 'def'}
        ];

        // When
        const result = averagePrice(data);

        // Then
        expect(result).toBeNaN();
    });

    // Process a list with null or undefined price values
    it('should return NaN for null or undefined price values', () => {
        // Given
        const data = [
            {price: null},
            {price: undefined}
        ];

        // When
        const result = averagePrice(data);

        // Then
        expect(result).toBeNaN();
    });

    // Handle a list with negative price values
    it('should handle negative price values correctly', () => {
        // Given
        const data = [
            {price: -100},
            {price: -200},
            {price: -300}
        ];

        // When
        const result = averagePrice(data);

        // Then
        expect(result).toBe(-200);
    });

    // Ensure the function returns NaN when dividing by zero
    it('should return NaN when dividing by zero', () => {
        // Given
        const data = [];

        // When
        const result = averagePrice(data);

        // Then
        expect(result).toBeNaN();
    });

    // Verify the function's performance with a large dataset
    it('should perform well with a large dataset', () => {
        // Given
        const data = Array.from({length: 1000000}, (_, i) => ({price: i + 1}));

        // When
        const startTime = performance.now();
        const result = averagePrice(data);
        const endTime = performance.now();

        // Then
        expect(result).toBeCloseTo(500000.5, 1);
        expect(endTime - startTime).toBeLessThan(1000); // Ensure it runs within 1 second.
    });

    // Check the function's behavior with extremely high price values
    it('should handle extremely high price values correctly', () => {
        // Given
        const data = [
            {price: Number.MAX_SAFE_INTEGER},
            {price: Number.MAX_SAFE_INTEGER}
        ];

        // When
        const result = averagePrice(data);

        // Then
        expect(result).toBe(Number.MAX_SAFE_INTEGER);
    });

    // Ensure the function handles floating-point price values correctly
    it('should handle floating-point price values correctly', () => {
        // Given
        const data = [
            {price: 100.5},
            {price: 200.75},
            {price: 300.25}
        ];

        // When
        const result = averagePrice(data);

        // Then
        expect(result).toBeCloseTo(200.5, 1);
    });
});

// Generated by CodiumAI

describe('jsonSort', () => {

    // Sorts array of objects by price in ascending order
    it('should sort array of objects by price in ascending order', () => {
        // Given
        const input = [
            {price: 200, description: 'B'},
            {price: 100, description: 'A'},
            {price: 300, description: 'C'}
        ];
        // When
        const result = jsonSort(input);
        // Then
        expect(result).toEqual([
            {price: 100, name: 'A'},
            {price: 200, name: 'B'},
            {price: 300, name: 'C'}
        ]);
    });

    // Returns array of objects with only price and description properties
    it('should return array of objects with only price and description properties', () => {
        // Given
        const input = [
            {price: 200, description: 'B', extra: 'extra1'},
            {price: 100, description: 'A', extra: 'extra2'}
        ];
        // When
        const result = jsonSort(input);
        // Then
        expect(result).toEqual([
            {price: 100, name: 'A'},
            {price: 200, name: 'B'}
        ]);
    });

    // Handles array with multiple objects correctly
    it('should handle array with multiple objects correctly', () => {
        // Given
        const input = [
            {price: 200, description: 'B'},
            {price: 100, description: 'A'},
            {price: 300, description: 'C'}
        ];
        // When
        const result = jsonSort(input);
        // Then
        expect(result.length).toBe(3);
    });

    // Handles array with objects having numeric price values
    it('should handle array with objects having numeric price values', () => {
        // Given
        const input = [
            {price: 200, description: 'B'},
            {price: 100, description: 'A'}
        ];
        // When
        const result = jsonSort(input);
        // Then
        expect(result).toEqual([
            {price: 100, name: 'A'},
            {price: 200, name: 'B'}
        ]);
    });

    // Handles array with objects having string price values
    it('should handle array with objects having string price values', () => {
        // Given
        const input = [
            {price: "200", description: 'B'},
            {price: "100", description: 'A'}
        ];
        // When
        const result = jsonSort(input);
        // Then
        expect(result).toEqual([
            {price: "100", name: 'A'},
            {price: "200", name: 'B'}
        ]);
    });

    // Handles empty array input
    it('should handle empty array input', () => {
        // Given
        const input = [];
        // When
        const result = jsonSort(input);
        // Then
        expect(result).toEqual([]);
    });

    // Handles array with objects missing price property
    it('should handle array with objects missing price property', () => {
        // Given
        const input = [
            {description: 'A'},
            {price: 100, description: 'B'}
        ];
        // When
        const result = jsonSort(input);
        // Then
        expect(result).toEqual([
            {price: 100, name: 'B'},
            {price: undefined, name: 'A'}
        ]);
    });

    // Handles array with objects missing description property
    it('should handle array with objects missing description property', () => {
        // Given
        const input = [
            {price: 100},
            {price: 200, description: 'B'}
        ];
        // When
        const result = jsonSort(input);
        // Then
        expect(result).toEqual([
            {price: 100, name: undefined},
            {price: 200, name: 'B'}
        ]);
    });

    // Handles array with objects having non-numeric price values
    it('should handle array with objects having non-numeric price values', () => {
        // Given
        const input = [
            {price: "abc", description: 'A'},
            {price: "100", description: 'B'}
        ];
        // When
        const result = jsonSort(input);
        // Then
        expect(result).toEqual([
            {price: "100", name: 'B'},
            {price: NaN, name: 'A'}
        ]);
    });

    // Handles array with objects having null or undefined price values
    it('should handle array with objects having null or undefined price values', () => {
        // Given
        const input = [
            {price: null, description: 'A'},
            {price: undefined, description: 'B'}
        ];
        // When
        const result = jsonSort(input);
        // Then
        expect(result).toEqual([
            {price: null, name: 'A'},
            {price: undefined, name: 'B'}
        ]);
    });
});

